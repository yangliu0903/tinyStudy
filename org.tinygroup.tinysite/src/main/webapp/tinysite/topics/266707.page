#pageTitle("topic" "topic")
#title("Tiny框架" "主题切换及其管理")
#[[<div class="BlogContent"><p>在Tiny的并行计算中，引用了远程方法调用工程，就是这里说的TinyRMI，当时在写测试用例的时候，只是在单机进行了测试，一切安好，但是Dawn在使用时，在多机进行试用，结果就出现了问题，最后花了不下一人周，才解决了Dawn发现的问题，最终解决了问题，也发现了RMI中的一些坑。可能有的人已经走过了，有的人如果没有碰到，也可能会掉同样的坑，因此把它成文，以飨读者，避免上同样的当。</p><p><span style="line-height:1.5;font-size:12.5px;">此文的形成离不开<strong>Dawn</strong>的深入测试与分析，在此表示深深感谢！</span></p><span id="OSC_h1_1"></span><h1>功能需求</h1><p>期望对Jdk中的Rmi进行一定的封装提供以下特性：</p><ol><li><span style="line-height:1.5;font-size:12.5px;">支持本地对象注册与注销</span></li><li><span style="line-height:1.5;font-size:12.5px;">支持远程对象注册与注销</span></li><li><span style="line-height:1.5;font-size:12.5px;">支持断线重连<br></br>由于网络故障，导致连接断开，在网络故障恢复之后，可以继续正常访问<br></br>由于RmiServerLocal停止，重新启动后，客户端注册的对象要继续可以正常访问<br></br>由于RmiServerRemote停止 ，重新启动后，客户端注册的对象需要重新注册</span></li><li><span style="line-height:1.5;font-size:12.5px;">支持对象校验<br></br>如果某些对象已经失效，服务器端可以把它从注册表去除，以避免别人拿到失效的对象</span></li></ol><span id="OSC_h1_2"></span><h1>接口设计</h1><p><span style="line-height:1.5;font-size:12.5px;">&amp;nbsp;<img src="http://static.oschina.net/uploads/space/2014/0520/075159_D7O2_1245989.png" alt=""></img></span></p><p><span style="line-height:1.5;font-size:12.5px;">可以看到RmiServer是继承了Serializable和Remote接口的一个接口，它提供了注册对象及取消注册对象的多个方法。当然也提供了一些辅助方法，看起来还是非常简单的。</span></p><p><span style="line-height:1.5;font-size:12.5px;">另外还有一个辅助接口Verifiable，对于加入的远程对象，如果实现了此接口，则可以对其有效性进行验证，如果已经失效，将被自动从注册无中去除。</span></p><p><span style="line-height:1.5;font-size:12.5px;"></span></p><pre class="brush:java; toolbar: true; auto-links: false;">/**
 * 是否可验证,实现了此接口的类，可以进行校验
 */
public interface Verifiable {
    /**
     * 校验，如果校验时不出现异常，就表示是OK的
     *
     * @throws RemoteException
     */
    void verify() throws RemoteException;
}</pre><p><span style="font-size:12.5px;line-height:1.5;">当然，要加入到RmiServer中，也要有一定的约束，因此设定了接口RemoteObject</span></p><p><span style="line-height:1.5;font-size:12.5px;"></span></p><pre class="brush:java; toolbar: true; auto-links: false;">public interface RemoteObject extends Serializable, Remote {
}</pre><p><span style="font-size:12.5px;line-height:1.5;">好的，至此为止，接口就算设计完了。</span></p><span id="OSC_h1_3"></span><h1>代码实现</h1><p><span style="line-height:1.5;font-size:12.5px;">第一版代码实现，偶预想的非常简单，如何获取Registry作为一个抽象方法由子类实现，其它都是针对Registry进行的操作，就放在抽象类中实现，分分钟写好，然后本地测试通过，洋洋自得中，却蒙蒙然不知犯下了严重的错误.....</span></p><p><span style="line-height:1.5;font-size:12.5px;">在单机环境下，测试都是好的，不管是RMI自己的测试用例还是复用它的并行计算工程。</span></p><p><span style="line-height:1.5;font-size:12.5px;">但是Dawn在使用的时候，采用了Linux机器两个物理机进行测试，问题出现了，错误信息如下：</span></p><p><span style="line-height:1.5;font-size:12.5px;"></span></p><pre class="brush:java; toolbar: true; auto-links: false;">java.rmi.AccessException: Registry.Registry.bind disallowed; origin / 192.168.xxx.xxx is non-local host</pre><p><span style="font-size:12.5px;line-height:1.5;">我们用物理的两台计算机进行测试，也有同样的问题。</span></p><p><span style="line-height:1.5;font-size:12.5px;">于是Baidu、谷歌都用上了，查找了终于找到原因：</span></p><p><span style="line-height:1.5;font-size:12.5px;">Registry只有本地的才可以对注册表进行修改，远程的只能用来查看。</span></p><p>于是把RmiServerLocal作为一个远程对象提供出来，让RmiServerRemote来调用，心想这样总可以了吧？？但是还是不行，还是同样的问题。</p><p>仔细阅读JavaDoc文档和找到的一些材料，才理解了，这个bind过程只能在RmiServerLocal所在的机器中执行，即使是通过远程服务调用，它还是认为是在RmiServerRemote中调用的......这尼玛的坑爹了，这个RMI这么难用，设计者知道么？</p><p>这次改进，远程机注册的时候，只是添加到RmiServerLocal中的一个Queue中，然后在RmiServerLocal所在机器开一个扫描线程，来进行bind,unbind操作，这样总保证是在Local中执行了。</p><p>测试一下，确实OK了......还没有高兴半下，Dawn报过来，又出问题了。</p><p>Windows作Server，Linux做客户端的时候是OK的，但是Linux只要做服务器端就还是不行。</p><p>继续查找原因，看到资料说是因为Linux查找到IP与外部访问的IP不对应导致，需要修改/etc/hosts文件中的127.0.0.1到外部方面的IP地址。</p><p>修改之后，问题得到解决。</p><span id="OSC_h1_4"></span><h1>测试过程</h1><p>初步跑通之后，接下来就是各种各样的测试及各种各样的问题。</p><p>由于采用了异步注册的关系，导致注册时间过后一小段时间才可以访问注册到的对象。</p><p>有对象访问冲突问题，等等等等，总之就是测了改，改了测，最后终于修正完毕，终于有一个稳定的可用的版本出现了。</p><p>最后，由于原来的设想的代码共用基本上没有复用的价值了，因此RmiServerLocal和RmiServerRemote都是各自的实现，不再有共同的基类。</p><span id="OSC_h1_5"></span><h1>经验总结</h1><ol><li><span style="line-height:1.5;font-size:12.5px;">测试用例的编写一定要充分覆盖。</span></li><li><span style="line-height:1.5;font-size:12.5px;">涉及到网络方面的测试，不能仅在本地测试通过就可以，一定要用真实的环境进行测试。</span></li><li><span style="line-height:1.5;font-size:12.5px;">不同的操作系统处理还是有一些不同，不要太迷信Java的一次编写到处使用，事实是到处可以跑，在大多数情况下也是可以正确的跑的，但是有些外部条件不同，可能会导致故障的出现。</span></li></ol><p>关于RMI：</p><ol><li><span style="line-height:1.5;font-size:12.5px;">如果是客户端仅调用服务器端提供的对象，那么是非常简单的。</span></li><li><span style="line-height:1.5;font-size:12.5px;">如果是客户端也要向服务器注册远程对象，那么就需要采用异步的方式，搞一下注册或注销队列。</span></li></ol><p>代码本身不复杂，需要的同学，请自行查看源代码。</p><p><a href="https://git.oschina.net/tinyframework/tiny/tree/master/framework/org.tinygroup.rmi" target="_blank" rel="nofollow">https://git.oschina.net/tinyframework/tiny/tree/master/framework/org.tinygroup.rmi</a></p></div>]]#